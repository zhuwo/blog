[{"title":"iOS文档集合","date":"2023-09-11","path":"2023/09/11/iOS_Doc_Collection/","text":"苹果官方文档 Apple Developer Forums: https://forums.developer.apple.com/welcome UIKit | Apple Developer Documentation: https://developer.apple.com/documentation/uikit Apple Developer Documentation：https://developer.apple.com/documentation/ Apple Developer：https://developer.apple.com/ Guides and Sample Code： https://developer.apple.com/library/content/navigation/ Apple Open Source: https://opensource.apple.com/ 语言文档（Swift &amp; Objective-C） Swift官方文档：https://www.cnswift.org/ Swift代码规范： http://yy.phiwifi.com/commdoc/code_standard/swift.html object-c文档：https://www.tutorialspoint.com/objective_c/objective_c_functions.htm Objective-C 代码规范：https://www.zybuluo.com/Sweetfish/note/509066 Objective-C api文档：https://developer.apple.com/reference/uikit Programming Guide String Programming Guide Attributed String Programming Guide Date and Time Programming Guide Text Programming Guide for iOS Core Text Programming Guide Thread Programming Guide File System Programming Guide Resource Programming Guide Bundle Programming Guide"},{"title":"iOS第三方库","date":"2023-09-10","path":"2023/09/10/iOS_Third_Library/index/","text":"学习地方库，不仅可以学习相关的原理，也可以学习优秀库的一些方法和编程思想 AFNetworking YYCache TZImagePicker"},{"title":"iOS 实现解决生产者消费者问题","date":"2023-09-09","path":"2023/09/09/producer-consumer/","text":"先是生产者要解决生产者过剩的问题， 消费者没有可消费的产品要等待 考虑CPU，++操作可能不是原子操作，需要对齐进行加锁，解决线程不安全问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445@proppery(nonatomic, strong) dispatch_semaphore_t pro_semaphore;@proppery(nonatomic, strong) dispatch_semaphore_t cus_semaphore;@proppery(nonatomic, strong) NSInterger producer_count;@proppery(nonatomic, strong) NSLock lock;#define BUFFER_SIZE 5;- (void)init &#123; if (self = [super init]) &#123; self.pro_semaphore = dispatch_semaphore_create(BUFFER_SIZE); self.cus_semaphore = dispatch_semaphore_create(0); self.producer_count = 0; self.lock = [[NSLock alloc] init]; &#125; return self;&#125;- (void)producer &#123; dispath_async(dispath_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(_pro_semaphore); [self.lock lock]; producer_count++; [self.lock unlock]; dispatch_semaphore_signal(_cus_semaphore); &#125;);&#125;- (void)consumer &#123; dispath_async(dispath_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(_cus_semaphore); [self.lock lock]; producer_count--; [self.lock unlock]; dispatch_semaphore_signal(_pro_semaphore); &#125;);&#125; 参考 GCD 解决生产者消费者问题"},{"title":"AFNetworking-Reading-Notes","date":"2023-09-04","path":"2023/09/04/iOS_Third_Library/AFNetworking-Reading-Notes/","text":"知名的网络第三方开源库。 作用 session的任务的回调收拢，和任务绑定进度回调，https的安全处理也包括了 类AFHTTPSessionManagerAFHTTPSessionManager继承自AFURLSessionManager，使用AFJSONResponseSerializer，AFSecurityPolicy（https）,AFNetworkReachabilityManager（网络状态）NSURLSessionConfiguration（URLSession配置，关于http协议的很多实现，例如http2.0支持keep-alive，保留tcp连接） NSURLSession设置的delegateQueue，是回调的时候的处理队列，当设置maxConcurrentOperationCount为1, 可以达到并发的请求串行的进行回调的效果。 核心类AFURLSessionManager首先对所有dataTask,uploadTask,downLoadTask，添加监听代理（可以获取进度）和通知。taskDidResume&#x2F;taskDidSuspend，接收taskResume，并发出通知AFNetworkingTaskDidResumeNotification，taskDidSuspend同理 所有代理有统一词典管理mutableTaskDelegatesKeyedByTaskIdentifier。任务结束didCompleteWithError，移除代理，并调用taskDidComplete回调。tasksForKeyPath，获取对应任务，留给子类使用。 hook resume&#x2F;suspend方法，发送对应通知 1. 给请求封装了进度的回调，包括上传&#x2F;下载&#x2F;数据任务. 2. 将NSURLSession的所有代理，包装成了block，跟任务绑定进度 接收挑战时（didReceiveChallenge），用securityPolicy进行证书认证等SSL流程。 _AFURLSessionTaskSwizzling傀儡类，给localDataTask(sessionTask)添加af_resume方法，af_suspend方法，并hook系统的resume&#x2F;suspend方法，获取resume和suspend的通知，发送对应通知给AFURLSessionManager。 AFURLSessionManagerTaskDelegate主要是记录进度，并持有进度回调block以便任务能添加进度回调，以及完成任务的回调，同时收拢不同任务（比方说都跟下载进度相关有数据任务、下载任务等都统一收拢到downloadProgress）。 通过KVO，用来接收进度变化，并回调进度和完成的任务，包含NSURLSessionTaskDelegate、NSURLSessionDataDelegate（下载、上传）、NSURLSessionDownloadDelegate（下载）。 AFSecurityPolicy猜测大概是https的应用，模式有pinningModeCertificate/publicKey/None，none就是什么也不验证，Certificate验证证书所有字段，包括有效期之内，publicKey只验证证书中的公钥。 pinningModeCertificate模式下，会建立ssl，认证domain的有效性 AFNetworkReachabilityManager网络状态检测单例，AFNetworkReachabilityStatus网络状态，wifi/4g/无？，初始化就会用linux系统方法获取reachability，然后startMonitoring方法会注册监听网络状态的变化，并发送通知（如果网络状态变化，SCNetworkReachability系列系统方法）。 AFJSONResponseSerializerAFJSONResponseSerializer继承自AFHTTPResponseSerializer，拥有acceptableStatusCodes（2**）和acceptableContentTypes（MINE中的），AFJSONResponseSerializer包含”application&#x2F;json”, @”text&#x2F;json”, @”text&#x2F;javascript”，其中responseObjectForResponse方法，会将错误包装返回 AFHTTPSessionManager对外接口，http协议的get&#x2F;post&#x2F;put&#x2F;delete&#x2F;… 请求使用AFURLRequestSerialization构建，并用父类方法dataTaskWithRequest发起请求 AFURLRequestSerialization请求的封装（封装复杂的http请求构建） AFURLResponseSerialization对response的反序列化。 UIKitAFNetworkActivityIndicatorManager如何处理网络请求过快？用timer 如何处理网络请求过多? 用计数器表示 iOS基础知识NSLock,NSOperationQueue,SCNetworkReachability"},{"title":"YYCache-Reading-Notes","date":"2023-09-03","path":"2023/09/03/iOS_Third_Library/YYCache-Reading-Notes/","text":"优秀的Cache库，使用LRU实现，拥有较好的性能。 结构 YYCache由DiskCache和MemoryCache组成，主要Api: containsObjectForKey，setObjectForKey, removeObjectForKey，removeAllObjects等等。 MemoryCachemutex保证线程安全，所有操作都加互斥锁 关于剪枝：trimToCost：不断的删除末尾节点，知道消耗和小雨costLimitautoTrimInterval:每隔5s，定时减末尾的枝 LRU: 所有操作都会将当前节点放到头部节点，保证最近使用的放到最前。 DiskCacheglobalCache存储所有storage的最大NSMapTable使用YYKVStorage存储到文件或数据库YYLinkedMapNode：双向链表，存储节点，YYLinkedMap， _head， _tail dispatch_semaphore_t保证线程安全 使用LRU删除节点，删除访问时间最老的数据，直到满足大小&#x2F;个数条件为止 所有操作都是YYKVStorage的操作，添加队列操作，增加一些功能（进度。。。），以及加锁保证线程安全。 YYKVStoragesaveItemWithKey：优先存文件，存文件失败村sqliteremoveItemForKey: 根据类型，删除文件或数据库内容removeItemsLargerThan（Size&#x2F;Time）:数据库字段已经存入，根据条件找到对应FileNames并删除剩下都是数据库操作 iOS支持要点NSMapTable, 对key,value弱引用NSKeyedArchiver"},{"title":"TZ_Reading_Notes","date":"2023-08-30","path":"2023/08/30/iOS_Third_Library/TZ-Reading-Notes/","text":"比较知名的图片选择器源码阅读和理解。TZImagePciker是一款github star超过8k的图片选择库。地址：https://github.com/banchichen/TZImagePickerController LxGridViewFlowLayout 使用了这个Layout，主要是实现CollectionView Cell可以拖拽的效果，添加了长按的手势识别，不断更新浮动的位置，一旦拖拽的位置到达新的位置，就用performBatchUpdates更新cell位置，已实现拖拽换位置的效果。 Demo入口 拍照和拍视频，使用系统提供的UIImagePickerController;相册使用TZImagePickerController。 TZImagePickerController 是一个UINavigationController，根VC是TZAlbumPickerController。第一次进入，push到TZPhotoPickerController，主要照片选择器。 TZPhotoPickerController 照片选择主体页面。来源，getCameraRollAlbumWithFetchAssets, 获取图片getPhotoWithAsset， 点击图片预览TZPhotoPreviewController。 拍照cell，点击跳到系统拍照的ImagePickerController。 Done按钮: 按operation获取选择的照片内容并返回，跳出pop presentedViewController。 FullImage按钮：showPhotoBytes -&gt; getPhotosBytesWithArray,会获取当前所选的照片的原图大小 TZAlbumPickerController 相册选择列表页面 TZImageManager1. 权限获取和权限状态管理 2. 照片处理-- Get Album 获得相册/相册数组方法： getCameraRollAlbumWithFetchAssets 3. 获取对应照片：getPhotoWithAsset TZPhotoPreviewController 大页面CollectionView, 每个Cell占满一个屏幕，滚动翻页系统自带collectionView.pagingEnabled。"},{"title":"iOS知识点","date":"2023-08-29","path":"2023/08/29/iOS/","text":"weak实现原理参考链接：https://www.jianshu.com/p/f331bd5ce8f8 weak由runtime持有的weak_table实现，每个对象有对应的weak_entry_t 获取oldobj(弱引用所指向的之前对象) unregister，替换为newobj的hashtable, register，weak表是hash表，对象的weak指针数组，销毁对象的时候所有weakrefernce置为nil KVO 实现原理参考：https://juejin.cn/post/6844903593925935117 iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类(KVONOtification)，子类拥有自己的set方法实现，set方法实现内部会顺序调用willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。 如何扩大点击区域事件响应链会调用pointInSide，重写pointInSide，edgeInsets扩大范围检测 OC实现链式调用https://juejin.cn/post/7010958824933130253 提供返回block的方法， block内部返回self，返回self是实现链式的核心。 自动释放池内对象释放时机https://juejin.cn/post/7010726670181253127 自动释放池对象AutoreleasePool被销毁时，有可能是当前runloop结束进入休眠，会对池内的所有对象发送release指令。本质是有个双向链表存储所有池内对象，一页放满就新建一页，放入新的页面中。 Struct和Class的区别 Comparision |Class Structure Type Classes are reference types. Structures are value types. Inheritance Classes have an inheritance that allows one class to inherit the characteristics of another. Structures do not support inheritance. Storage Class instances are stored on the heap. Structure properties are stored on the stack. Initializer We have to define the initializer manually. Struct gets a default initializer automatically. Thread−safe Classes are not fully thread−safe. The structure is thread−safe or singleton at all times. Category实现原理https://juejin.cn/post/6844903602524274696 从源码基本可以看出我们平时使用categroy的方式，对象方法，类方法，协议，和属性都可以找到对应的存储方式。并且我们发现分类结构体中是不存在成员变量的，因此分类中是不允许添加成员变量的。分类中添加的属性并不会帮助我们自动生成成员变量，只会生成get set方法的声明，需要我们自己去实现。 category的方法会在运行时加到原来类的方法列表之前，所有category的方法协议会覆盖原来类的方法和协议等。 category中有load方法，先执行原来的load方法，load方法在类加载时候调用,initalize在类第一次使用的时候调用。 关联对象（添加新的成员变量）https://juejin.cn/post/6844903605347057672 AssociationsManager拥有AssociationsHashMap&#x3D;&gt;value为ObjectAssociationMap&#x3D;&gt;valuew为ObjcAssociation（set_assoicated设置的_policy、value）。 通过上图我们可以总结为：一个实例对象就对应一个ObjectAssociationMap，而ObjectAssociationMap中存储着多个此实例对象的关联对象的key以及ObjcAssociation，为ObjcAssociation中存储着关联对象的value和policy策略。 GCDhttps://www.jianshu.com/p/2d57c72016c6 主队列上执行同步任务卡死的原因1234567891011dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; // 异步执行 + 串行队列 NSLog(@&quot;add task&quot;); NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 dispatch_sync(queue, ^&#123; // 同步执行 + 当前串行队列 // 追加任务 1 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); &#125;); dispatch_sync添加的任务执行完以后才会返回，因为是串行队列，所有只有dispatch_sync任务执行完，才会执行下一个任务【追加任务 1】，所有一直追加任务等待dispatch_sync执行完成主队列是串行队列，跟这个情况一样。 block为什么用copy修饰?默认情况下，block 是存放在栈中即 NSStackBlock ，因此 block 在函数调用结束时，对象会变成 nil，但是对象的指针变成野指针，因此对象继续调用会产生异常。使用 copy 修饰之后，会将 block 对象保存到堆中 NSMallocBlock，它的生命周期会随着对象的销毁而结束的。所以函数调用结束之后指针也会被设置为 nil，再次调用该对象也不会产生异常。 iOS保证线程安全的几种方式https://juejin.cn/post/6965770220921159694 OSSpinLock os_unfair_lock pthread_mutex dispatch_semaphore dispatch_queue(DISPATCH_QUEUE_SERIAL) NSLock NSRecursiveLock NSCondition NSConditionLock @synchronized NSDic"},{"title":"algorithms","date":"2023-07-12","path":"2023/07/12/algorithms/","text":"算法和数据结构回溯 DFS+遍历探索每一层的每一种可能 画出所有树状链路就能写出代码 效率比较低"},{"title":"Hello World","date":"2022-12-31","path":"2022/12/31/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]