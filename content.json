[{"title":"The super tiny compiler研究","date":"2023-10-12","path":"2023/10/12/the-super-tiny-compiler/","text":"The super tiny compiler Github非常有名的超级简单的编译器实现。 测试从作者的测试着手，了解编译器的功能。 输入输出12const input = &#x27;(add 2 (subtract 4 2))&#x27;;const output = &#x27;add(2, subtract(4, 2));&#x27;; 输入input是个后缀表达式，后缀表达式的操作符为啥以(开头呢，我猜测是为了方便判断是操作符，一个操作的开头都是操作符，结束的地方以)结束一个简单操作，比如：(subtract 4 2)。输出output是个中缀表达式。 完整编译过程1. tokenizer，词法分析，inuput输入=&gt;token数组 2. parser，语法分析，token数组=&gt;AST 3. transformer,语法树替换，AST=&gt;newAST 4. codeGenerator, newAST=&gt;output 5. compiler, 输入input=&gt;输出output 词法分析 Lexical Analysis扫描输入，变为： 1234567891011[ &#123; type: &#x27;paren&#x27;, value: &#x27;(&#x27; &#125;, &#123; type: &#x27;name&#x27;, value: &#x27;add&#x27; &#125;, &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27; &#125;, &#123; type: &#x27;paren&#x27;, value: &#x27;(&#x27; &#125;, &#123; type: &#x27;name&#x27;, value: &#x27;subtract&#x27; &#125;, &#123; type: &#x27;number&#x27;, value: &#x27;4&#x27; &#125;, &#123; type: &#x27;number&#x27;, value: &#x27;2&#x27; &#125;, &#123; type: &#x27;paren&#x27;, value: &#x27;)&#x27; &#125;, &#123; type: &#x27;paren&#x27;, value: &#x27;)&#x27; &#125;,] 实际程序： 扫描字符，状态机 如果遇到数字，就是数字；遇到(就是(。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157function tokenizer(input) &#123; // A `current` variable for tracking our position in the code like a cursor. let current = 0; // And a `tokens` array for pushing our tokens to. let tokens = []; // We start by creating a `while` loop where we are setting up our `current` // variable to be incremented as much as we want `inside` the loop. // // We do this because we may want to increment `current` many times within a // single loop because our tokens can be any length. while (current &lt; input.length) &#123; // We&#x27;re also going to store the `current` character in the `input`. let char = input[current]; // The first thing we want to check for is an open parenthesis. This will // later be used for `CallExpression` but for now we only care about the // character. // // We check to see if we have an open parenthesis: if (char === &#x27;(&#x27;) &#123; // If we do, we push a new token with the type `paren` and set the value // to an open parenthesis. tokens.push(&#123; type: &#x27;paren&#x27;, value: &#x27;(&#x27;, &#125;); // Then we increment `current` current++; // And we `continue` onto the next cycle of the loop. continue; &#125; // Next we&#x27;re going to check for a closing parenthesis. We do the same exact // thing as before: Check for a closing parenthesis, add a new token, // increment `current`, and `continue`. if (char === &#x27;)&#x27;) &#123; tokens.push(&#123; type: &#x27;paren&#x27;, value: &#x27;)&#x27;, &#125;); current++; continue; &#125; // Moving on, we&#x27;re now going to check for whitespace. This is interesting // because we care that whitespace exists to separate characters, but it // isn&#x27;t actually important for us to store as a token. We would only throw // it out later. // // So here we&#x27;re just going to test for existence and if it does exist we&#x27;re // going to just `continue` on. let WHITESPACE = /\\s/; if (WHITESPACE.test(char)) &#123; current++; continue; &#125; // The next type of token is a number. This is different than what we have // seen before because a number could be any number of characters and we // want to capture the entire sequence of characters as one token. // // (add 123 456) // ^^^ ^^^ // Only two separate tokens // // So we start this off when we encounter the first number in a sequence. let NUMBERS = /[0-9]/; if (NUMBERS.test(char)) &#123; // We&#x27;re going to create a `value` string that we are going to push // characters to. let value = &#x27;&#x27;; // Then we&#x27;re going to loop through each character in the sequence until // we encounter a character that is not a number, pushing each character // that is a number to our `value` and incrementing `current` as we go. while (NUMBERS.test(char)) &#123; value += char; char = input[++current]; &#125; // After that we push our `number` token to the `tokens` array. tokens.push(&#123; type: &#x27;number&#x27;, value &#125;); // And we continue on. continue; &#125; // We&#x27;ll also add support for strings in our language which will be any // text surrounded by double quotes (&quot;). // // (concat &quot;foo&quot; &quot;bar&quot;) // ^^^ ^^^ string tokens // // We&#x27;ll start by checking for the opening quote: if (char === &#x27;&quot;&#x27;) &#123; // Keep a `value` variable for building up our string token. let value = &#x27;&#x27;; // We&#x27;ll skip the opening double quote in our token. char = input[++current]; // Then we&#x27;ll iterate through each character until we reach another // double quote. while (char !== &#x27;&quot;&#x27;) &#123; value += char; char = input[++current]; &#125; // Skip the closing double quote. char = input[++current]; // And add our `string` token to the `tokens` array. tokens.push(&#123; type: &#x27;string&#x27;, value &#125;); continue; &#125; // The last type of token will be a `name` token. This is a sequence of // letters instead of numbers, that are the names of functions in our lisp // syntax. // // (add 2 4) // ^^^ // Name token // let LETTERS = /[a-z]/i; if (LETTERS.test(char)) &#123; let value = &#x27;&#x27;; // Again we&#x27;re just going to loop through all the letters pushing them to // a value. while (LETTERS.test(char)) &#123; value += char; char = input[++current]; &#125; // And pushing that value as a token with the type `name` and continuing. tokens.push(&#123; type: &#x27;name&#x27;, value &#125;); continue; &#125; // Finally if we have not matched a character by now, we&#x27;re going to throw // an error and completely exit. throw new TypeError(&#x27;I dont know what this character is: &#x27; + char); &#125; // Then at the end of our `tokenizer` we simply return the tokens array. 语法分析 Syntactic Analysis输入：token数组输出；ast walk递归函数： 遇到Number\\String，直接返回对应JSON结构 遇到(,构建表达式，循环一直push，walk返回的结果，直到遇到)，返回表达式node 总结： 后缀表达式的解析，相对简单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let current = 0;function walk() &#123; let token = tokens[current]; if (token.type === &#x27;number&#x27;) &#123; current++; return &#123; type: &#x27;NumberLiteral&#x27;, value: token.value &#125; &#125; if (token.type === &#x27;string&#x27;) &#123; current++; return &#123; type: &#x27;StringLiteral&#x27;, value: token.value &#125; &#125; if (token.type == &#x27;paren&#x27; &amp;&amp; token.value == &#x27;(&#x27;) &#123; token = tokens[++current]; let node = &#123; type: &#x27;CallExpression&#x27;, name: token.name, params:[] &#125; token = tokens[++current]; while (token.type !== &#x27;paren&#x27; || token.type === &#x27;paren&#x27; &amp;&amp; token.value !== &#x27;)&#x27;) &#123; node.params.push(walk()); token = tokens[current]; &#125; ++current; return node; &#125; throw TypeError(token.type)&#125;let ast = &#123; type: &#x27;Program&#x27;, body:[]&#125;while(current &lt; token.length()) &#123; ast.body.push(walk());&#125;return ast; 123456789101112131415161718192021&#123; type: &#x27;Program&#x27;, body: [&#123; type: &#x27;CallExpression&#x27;, name: &#x27;add&#x27;, params: [&#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;2&#x27;, &#125;, &#123; type: &#x27;CallExpression&#x27;, name: &#x27;subtract&#x27;, params: [&#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;4&#x27;, &#125;, &#123; type: &#x27;NumberLiteral&#x27;, value: &#x27;2&#x27;, &#125;] &#125;] &#125;] &#125; 变换 Transformation任何想对原始AST进行的处理，包括增加、删除、替换节点 遍历 Traversal Program - Starting at the top level of the AST CallExpression (add) - Moving to the first element of the Program’s body NumberLiteral (2) - Moving to the first element of CallExpression’s params CallExpression (subtract) - Moving to the second element of CallExpression’s params NumberLiteral (4) - Moving to the first element of CallExpression’s params NumberLiteral (2) - Moving to the second element of CallExpression’s params 延伸扩展 优先级如何处理 语义如何处理"},{"title":"C++的一些简要操作笔记","date":"2023-10-01","path":"2023/10/01/cpp-simple-notes/","text":"清空queue c++ clear queue12std::queue&lt;int&gt; empty;std::swap( q, empty );"},{"title":"项目-动态化方案","date":"2023-09-21","path":"2023/09/21/dynamic-proposal/","text":"Question: ReactNative的渲染过程了解吗 如何保持双端UI的一致性 JS的数据如何转换为OC对应的数据类型 关注哪些性能指标 如何保持双端一致性： 应用统一的布局引擎Yoga,保证布局理念和原理 原子组件，文本、图片、Yoga语义效果一直，文本设计师出规范，行高字体大小确定的情况下居中对齐 缩放模式，双端都以375屏幕为基础单位， iPhone7&#x2F;iPhone8位标准，其他屏幕大小进行缩放 除了静态的UI对齐，只要语义一致就可以了 关注哪些性能指标https://www.51cto.com/article/681298.html 首屏绘制（First Paint，FP） 首屏内容绘制（First Contentful Paint，FCP） 可交互时间（Time to Interactive，TTI） 最大内容绘制 (Largest Contentful Paint，LCP) 首次有效绘制（First Meaning Paint, FMP）"},{"title":"招商银行iOS面试笔试","date":"2023-09-18","path":"2023/09/18/merchants-bank-iOS/","text":"笔试题 实现属性@propperty(nonatomic, strong) NSString* name和@propperty(nonatomic, copy) NSString* name的set方法 下列哪些操作可以在iOS后台运行a. VOIPb. 音乐播放c. 地理位置获取d. http请求 UIView和UIControl的关系 [super dealloc]需要在dealloc中调用吗，调用顺序是怎么样的 a. [super dealloc]在第一行 b. [super dealloc]在最后一行 c. 没有关系 @propery和@systhesis的作用 UIResponder，_____， 以及UIView能响应事件 哪个是单例 a. NSNotification b. UIApplication (sharedApplication) c. NSuserDefault (standardUserDefaults) d. 什么情况下使用delegate，什么情况下使用notification Delegate: 消息的发送者(sender)告知接收者(receiver)某个事件将要发生，delegate同意然然后发送者响应事件，delegate机制使得接收者可以改变发送者的行为。通常发送者和接收者的关系是直接的一对多的关系。 Notification: 消息的发送者告知接收者事件已经发生或者将要发送，仅此而已，接收者并不能反过来影响发送者的行为。通常发送者和接收者的关系是间接的多对多关系。 区别: a. 效率肯定是delegate比nsnotification高。 b. delegate方法比notification更加直接，最典型的特征是，delegate方法往往需要关注返回值，也就是delegate方法的结果。比如-windowShouldClose:，需要关心返回的是yes还是no。所以delegate方法往往包含should这个很传神的词。也就是好比你做我的delegate，我会问你我想关闭窗口你愿意吗？你需要给我一个答案，我根据你的答案来决定如何做下一步。相反的，notification最大的特色就是不关心接受者的态度，我只管把通告放出来，你接受不接受就是你的事情，同时我也不关心结果。所以notification往往用did这个词汇，比如NSWindowDidResizeNotification，那么nswindow对象放出这个notification后就什么都不管了也不会等待接受者的反应。 1）两个模块之间联系不是很紧密，就用notification传值，例如多线程之间传值用notificaiton。 2）delegate只是一种较为简单的回调，且主要用在一个模块中，例如底层功能完成了，需要把一些值传到上层去，就事先把上层的函数通过delegate传到底层，然后在底层call这个delegate，它们都在一个模块中，完成一个功能，例如说 NavgationController 从 B 界面到A 点返回按钮 (调用popViewController方法) 可以用delegate比较好。 什么情况下使用copy属性 a.对于不可变属性，推荐使用copy，能防止不可变对象变成可变对象，从而防止值发生不可控变化。 b.对于可变属性，推荐使用strong，因为用copy修饰后，会变成不可变对象，再调用可变对象的函数时会crash 面试题 CocoaPods原理，单独的库是如何打包的？ 大文件下载多线程如何实现，读取和下载完成，如何合并各个文件下载的进度 load系统是怎么调用的，initalize可以运行时调用吗？"},{"title":"iOS 多线程问题汇总","date":"2023-09-15","path":"2023/09/15/iOS-multi-thread/","text":"iOS实现多线程有哪些方法 NSThread GCD NSOperation 下面代码有问题吗123456789101112131415161718192021@inteface Person: NSObject@property(nonatomic, strong) NSString* name;@property(nonatomic, assign) NSInteger age;@property(nonatomic, strong) NSObject* object;@end;@implementation FBViewController@property(nonatomic, strong) NSMutableArray* myArray;- (void)testThread &#123; dispatch_queue_t q = dispatch_queue_create(&quot;com.queue&quot;, DISPATCH_QUEUE_SERIAL); for (int i = 0; i &lt; 100; ++i) &#123; dispatch_async(q, ^&#123; [self.myArray addObject:@(1)]; &#125;); &#125;&#125;@end 改为@property(atomic, strong) NSMutableArray* myArray会有问题吗？ 会。因为原子性只能保证读写安全，而该表达式需要三步操作： 1.先进行get, 读取i的值存入寄存器； 2.将寄存器的值加1； 3.使用寄存器修改后的值给i赋值； 以下内容会有循环引用吗？不调用testBlock会有吗？12345678910111213141516171819202122232425262728293031@inteface NewViewController()@property(nonatomic, strong) Block* block@end@implmentation NewViewController- (void)testBlock &#123; [self.block addblock:^&#123; self.view.backgroundColor = [UIColor redColor]; &#125;];&#125;@endtypedef void (^MyBlock)();@inteface Block@propery(nonatomic, strong) MyBlock block;@end@implmentation- (void)addBlock:(MyBlock)block &#123; self.block = block; if (self.block) &#123; self.block(); &#125;&#125;@end 接上边的block，以下代码会有问题吗1234567__weak typeof(self) weakSelf = self;[self.block addblock:^&#123; __strong typeof(weakSelf) strongSelf = self; strongSelf-&gt;preson.name = @&quot;&quot;; strongSelf-&gt;preson.object = [NSObject new]; // weakSelf-&gt;person.name = @&quot;jiang&quot;;&#125;]; 延迟执行block会有问题吗？不会，因为有strong保证VC不会提前释放 self为null会有问题吗 weakSelf-&gt;直接访问会奔溃（成员变量），.name走的是消息转发不会奔溃 OC向nil发送消息，是不会崩溃的。 OC的函数调用都是通过objc_msgSend进行消息发送来实现，相对于C/C++来说，操作空指针引起crash问题， objc_msgSend通过判断self来决定是否发送消息，self为nil，那么selector也为空，直接返回，所以不会崩溃 是在新的子线程执行的吗？以下代码打印顺序是怎么样的？12345678910111213- (void)MyLog &#123; NSLog(@&quot;3&quot;);&#125;- (void)testBlock2 &#123; NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); dispatch_queue_t q2 = dispatch_queue_create(&quot;com.queue.queue2&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(q2, ^&#123; NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); NSLog(@&quot;1&quot;); [self performSelector:@selector(MyLog) withObject:self afterDelay:2.0]; NSLog(@&quot;2&quot;); &#125;);&#125; 打印出”12”， 3不会打印，2执行完后，线程就退出了 下边代码会有问题吗？123456789dispatch_queue_t q3 = dispatch_queue_create(&quot;com.queue.queue3&quot;, DISPATCH_QUEUE_SERIAL);for (int i = 0; i &lt; 100; ++i) &#123; dispatch_async(q3, ^&#123; person.name = @&quot;jiang&quot;; person.obj = [NSObject new]; &#125;)；&#125; 对象重新赋值，会多次release，造成奔溃。"},{"title":"基金指标","date":"2023-09-12","path":"2023/09/12/fund_target/","text":"最大回撤率什么是最大回撤率？我们先看一下百度词条的解释：最大回撤率是指在选定周期内任一历史时点往后推，产品净值走到最低点时的收益率回撤幅度的最大值。是不是感觉没怎么听懂？我用通俗的语言给大家翻译一下：也就是一定时间内，比如一年以内，基金净值从前期最高点，跌倒最低点，这下跌的幅度，就是最大回撤率。还是不能了解？没有关系，我们用个例子来给大家讲解。假设现在有一只基金，过去的一年，基金的净值从1块钱涨到了2块钱，最后又跌下来，到了1.5元。那么基金的净值从2块钱，跌倒1.5元这个下跌的幅度，就是这只基金的最大回撤率。计算公式就为：（2-1.5）&#x2F;2*100%&#x3D;25%。 夏普比率简单来讲，夏普比率就是衡量在每承担1个单位风险的情况下，所获得超越无风险收益率的超额回报是多少。夏普比率越高，说明在承担一定风险的情况下，所获得的超额回报越高。反之，如果夏普比率很小甚至为负，说明承担一定的风险所获的超额回报很小或者没有超额回报。这非常像我们日常生活中的概念，叫作“性价比”，就是每付出一点价格就获得多少的性能。基金风险平均回报平均回报为年度化的平均月几何回报，得出数据未必与过去一年实际年度回报相等。 标准差反映计算期内总回报率的波动幅度，即基金每月的总回报率相对于平均月回报率的偏差程度，波动越大，标准差也越大。 夏普比率夏普比率是衡量基金风险调整后收益的指标之一，反映了基金承担单位风险所获得的超额回报率（Excess Returns），即基金总回报率高于同期无风险收益率的部分，一般情况下，该比率越高，基金承担单位风险得到的超额回报率越高。 晨星风险系数晨星风险系数反映计算期内相对于同类基金，基金收益向下波动的风险。其计算方法为：相对无风险收益率的基金平均损失除以同类别平均损失。一般情况下，该指标越大，下行风险越高。 相对表现阿尔法系数（α）阿尔法系数（α）是基金的实际收益和按照β系数计算的期望收益之间的差额。其计算方法如下：超额收益是基金的收益减去无风险投资收益（在中国为1年期银行定期存款收益）；期望收益是贝塔系数β和市场收益的乘积，反映基金由于市场整体变动而获得的收益；超额收益和期望收益的差额即α系数。 贝塔系数（β）贝塔系数衡量基金收益相对于业绩评价基准收益的总体波动性，是一个相对指标。β越高，意味着基金相对于业绩评价基准的波动性越大。β大于1 ，则基金的波动性大于业绩评价基准的波动性。反之亦然。如果β为1 ，则市场上涨10％，基金上涨10％；市场下滑10％，基金相应下滑10％。如果β为 1.1,市场上涨10％时，基金上涨11%, ；市场下滑10％时，基金下滑11% 。如果β为 0.9, 市场上涨10％时，基金上涨9% ；市场下滑10％时，基金下滑9% 。 R平方R平方(R-squared)是反映业绩基准的变动对基金表现的影响，影响程度以0至100计。如果R平方值等于100 ，表示基金回报的变动完全由业绩基准的变动所致；若R平方值等于35，即35%的基金回报可归因于业绩基准的变动。简言之，R平方值愈低，由业绩基准变动导致的基金业绩的变动便愈少。此外，R平方也可用来确定贝塔系数（β）或阿尔法系数（α）的准确性。一般而言，基金的R平方值愈高，其两个系数的准确性便愈高。"},{"title":"金融经济类书单","date":"2023-09-12","path":"2023/09/12/booklist_finance/","text":"简要梳理了金融，经济学方面比较靠谱的书籍。 经济学 《经济学原理》 《货币银行学》 《资本论》 《国富论》 理财观念 《富爸爸穷爸爸》 《财富自由之路》 投资哲学 《穷查理宝典》 《巴芒演义：可复制的价值投资》 公司分析 《一本书读懂财务报表》 股票 《股市真规则》 《伟大的博弈》 《战胜华尔街》 《巴菲特致股东的信》 《彼得·林奇的成功投资》 《聪明的投资者》 《漫步华尔街》 《华尔街之狼》 基金 《解读基金：我的投资观与实践》 《指数基金投资指南》 《共同基金常识》 《基金理财系列丛书之一：开放式基金投资指南》 《共同基金常识》 《小乌龟投资智慧》 金融大类 《证券分析》 《聪明的投资者》 《Winning the Loser’s Game》"},{"title":"iOS文档集合","date":"2023-09-11","path":"2023/09/11/iOS_Doc_Collection/","text":"苹果官方文档 Apple Developer Forums: https://forums.developer.apple.com/welcome UIKit | Apple Developer Documentation: https://developer.apple.com/documentation/uikit Apple Developer Documentation：https://developer.apple.com/documentation/ Apple Developer：https://developer.apple.com/ Guides and Sample Code： https://developer.apple.com/library/content/navigation/ Apple Open Source: https://opensource.apple.com/ 语言文档（Swift &amp; Objective-C） Swift官方文档：https://www.cnswift.org/ Swift代码规范： http://yy.phiwifi.com/commdoc/code_standard/swift.html object-c文档：https://www.tutorialspoint.com/objective_c/objective_c_functions.htm Objective-C 代码规范：https://www.zybuluo.com/Sweetfish/note/509066 Objective-C api文档：https://developer.apple.com/reference/uikit Programming Guide String Programming Guide Attributed String Programming Guide Date and Time Programming Guide Text Programming Guide for iOS Core Text Programming Guide Thread Programming Guide File System Programming Guide Resource Programming Guide Bundle Programming Guide Quartz 2D Programming Guide"},{"title":"iOS第三方库","date":"2023-09-10","path":"2023/09/10/iOS_Third_Library/index/","text":"学习地方库，不仅可以学习相关的原理，也可以学习优秀库的一些方法和编程思想 AFNetworking YYCache TZImagePicker"},{"title":"iOS 实现解决生产者消费者问题","date":"2023-09-09","path":"2023/09/09/producer-consumer/","text":"先是生产者要解决生产者过剩的问题， 消费者没有可消费的产品要等待 考虑CPU，++操作可能不是原子操作，需要对齐进行加锁，解决线程不安全问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344@proppery(nonatomic, strong) dispatch_semaphore_t pro_semaphore;@proppery(nonatomic, strong) dispatch_semaphore_t cus_semaphore;@proppery(nonatomic, strong) NSInterger producer_count;@proppery(nonatomic, strong) NSLock lock;#define BUFFER_SIZE 5;- (void)init &#123; if (self = [super init]) &#123; self.pro_semaphore = dispatch_semaphore_create(BUFFER_SIZE); self.cus_semaphore = dispatch_semaphore_create(0); self.producer_count = 0; self.lock = [[NSLock alloc] init]; &#125; return self;&#125;- (void)producer &#123; dispath_async(dispath_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(_pro_semaphore); [self.lock lock]; producer_count++; [self.lock unlock]; dispatch_semaphore_signal(_cus_semaphore); &#125;);&#125;- (void)consumer &#123; dispath_async(dispath_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(_cus_semaphore); [self.lock lock]; producer_count--; [self.lock unlock]; dispatch_semaphore_signal(_pro_semaphore); &#125;);&#125; 参考 GCD解决生产者消费者问题"},{"title":"AFNetworking-Reading-Notes","date":"2023-09-04","path":"2023/09/04/iOS_Third_Library/AFNetworking-Reading-Notes/","text":"知名的网络第三方开源库。 作用 session的任务的回调收拢，和任务绑定进度回调 可扩展性增强，AFURLSessionManager封装底层的upload&#x2F;download&#x2F;dataTask，AFHTTPSessionManager,专门负责http协议的处理；也可以扩展出FTP的类进行FTP处理 单独处理https安全问题 类AFHTTPSessionManagerAFHTTPSessionManager继承自AFURLSessionManager，使用AFJSONResponseSerializer，AFSecurityPolicy（https）,AFNetworkReachabilityManager（网络状态）NSURLSessionConfiguration（URLSession配置，关于http协议的很多实现，例如http2.0支持keep-alive，保留tcp连接） NSURLSession设置的delegateQueue，是回调的时候的处理队列，当设置maxConcurrentOperationCount为1, 可以达到并发的请求串行的进行回调的效果。 核心类AFURLSessionManager首先对所有dataTask,uploadTask,downLoadTask，添加监听代理（可以获取进度）和通知。taskDidResume&#x2F;taskDidSuspend，接收taskResume，并发出通知AFNetworkingTaskDidResumeNotification，taskDidSuspend同理 所有代理有统一词典管理mutableTaskDelegatesKeyedByTaskIdentifier。任务结束didCompleteWithError，移除代理，并调用taskDidComplete回调。tasksForKeyPath，获取对应任务，留给子类使用。 hook resume&#x2F;suspend方法，发送对应通知 1. 给请求封装了进度的回调，包括上传&#x2F;下载&#x2F;数据任务. 2. 将NSURLSession的所有代理，包装成了block，跟任务绑定进度 接收挑战时（didReceiveChallenge），用securityPolicy进行证书认证等SSL流程。 _AFURLSessionTaskSwizzling傀儡类，给localDataTask(sessionTask)添加af_resume方法，af_suspend方法，并hook系统的resume&#x2F;suspend方法，获取resume和suspend的通知，发送对应通知给AFURLSessionManager。 AFURLSessionManagerTaskDelegate主要是记录进度，并持有进度回调block以便任务能添加进度回调，以及完成任务的回调，同时收拢不同任务（比方说都跟下载进度相关有数据任务、下载任务等都统一收拢到downloadProgress）。 通过KVO，用来接收进度变化，并回调进度和完成的任务，包含NSURLSessionTaskDelegate、NSURLSessionDataDelegate（下载、上传）、NSURLSessionDownloadDelegate（下载）。 AFSecurityPolicy猜测大概是https的应用，模式有pinningModeCertificate/publicKey/None，none就是什么也不验证，Certificate验证证书所有字段，包括有效期之内，publicKey只验证证书中的公钥。 pinningModeCertificate模式下，会建立ssl，认证domain的有效性 AFNetworkReachabilityManager网络状态检测单例，AFNetworkReachabilityStatus网络状态，wifi/4g/无？，初始化就会用linux系统方法获取reachability，然后startMonitoring方法会注册监听网络状态的变化，并发送通知（如果网络状态变化，SCNetworkReachability系列系统方法）。 AFJSONResponseSerializerAFJSONResponseSerializer继承自AFHTTPResponseSerializer，拥有acceptableStatusCodes（2**）和acceptableContentTypes（MINE中的），AFJSONResponseSerializer包含”application&#x2F;json”, @”text&#x2F;json”, @”text&#x2F;javascript”，其中responseObjectForResponse方法，会将错误包装返回 AFHTTPSessionManager对外接口，http协议的get&#x2F;post&#x2F;put&#x2F;delete&#x2F;… 请求使用AFURLRequestSerialization构建，并用父类方法dataTaskWithRequest发起请求 AFURLRequestSerialization请求的封装（封装复杂的http请求构建） AFURLResponseSerialization对response的反序列化。 UIKitAFNetworkActivityIndicatorManager如何处理网络请求过快？用timer 如何处理网络请求过多? 用计数器表示 iOS基础知识NSLock, NSOperationQueue, SCNetworkReachability"},{"title":"YYCache-Reading-Notes","date":"2023-09-03","path":"2023/09/03/iOS_Third_Library/YYCache-Reading-Notes/","text":"优秀的Cache库，使用LRU实现，拥有较好的性能。 结构 YYCache由DiskCache和MemoryCache组成，主要Api: containsObjectForKey，setObjectForKey, removeObjectForKey，removeAllObjects等等。 MemoryCachemutex保证线程安全，所有操作都加互斥锁 关于剪枝：trimToCost：不断的删除末尾节点，知道消耗和小雨costLimitautoTrimInterval:每隔5s，定时减末尾的枝 LRU: 所有操作都会将当前节点放到头部节点，保证最近使用的放到最前。 DiskCacheglobalCache存储所有storage的最大NSMapTable使用YYKVStorage存储到文件或数据库YYLinkedMapNode：双向链表，存储节点，YYLinkedMap， _head， _tail dispatch_semaphore_t保证线程安全 使用LRU删除节点，删除访问时间最老的数据，直到满足大小&#x2F;个数条件为止 所有操作都是YYKVStorage的操作，添加队列操作，增加一些功能（进度。。。），以及加锁保证线程安全。 YYKVStoragesaveItemWithKey：优先存文件，存文件失败村sqliteremoveItemForKey: 根据类型，删除文件或数据库内容removeItemsLargerThan（Size&#x2F;Time）:数据库字段已经存入，根据条件找到对应FileNames并删除剩下都是数据库操作 iOS知识要点NSMapTable, 对key，value弱引用NSKeyedArchiver"},{"title":"TZ_Reading_Notes","date":"2023-08-30","path":"2023/08/30/iOS_Third_Library/TZ-Reading-Notes/","text":"比较知名的图片选择器源码阅读和理解。TZImagePciker是一款github star超过8k的图片选择库。地址：https://github.com/banchichen/TZImagePickerController LxGridViewFlowLayout 使用了这个Layout，主要是实现CollectionView Cell可以拖拽的效果，添加了长按的手势识别，不断更新浮动的位置，一旦拖拽的位置到达新的位置，就用performBatchUpdates更新cell位置，已实现拖拽换位置的效果。 Demo入口 拍照和拍视频，使用系统提供的UIImagePickerController;相册使用TZImagePickerController。 TZImagePickerController 是一个UINavigationController，根VC是TZAlbumPickerController。第一次进入，push到TZPhotoPickerController，主要照片选择器。 TZPhotoPickerController 照片选择主体页面。来源，getCameraRollAlbumWithFetchAssets, 获取图片getPhotoWithAsset， 点击图片预览TZPhotoPreviewController。 拍照cell，点击跳到系统拍照的ImagePickerController。 Done按钮: 按operation获取选择的照片内容并返回，跳出pop presentedViewController。 FullImage按钮：showPhotoBytes -&gt; getPhotosBytesWithArray,会获取当前所选的照片的原图大小 TZAlbumPickerController 相册选择列表页面 TZImageManager1. 权限获取和权限状态管理 2. 照片处理-- Get Album 获得相册/相册数组方法： getCameraRollAlbumWithFetchAssets 3. 获取对应照片：getPhotoWithAsset TZPhotoPreviewController 大页面CollectionView, 每个Cell占满一个屏幕，滚动翻页系统自带collectionView.pagingEnabled。"},{"title":"iOS知识点","date":"2023-08-29","path":"2023/08/29/iOS/","text":"知识大乱炖，用于快速回忆知识点，。 weak实现原理参考链接：https://www.jianshu.com/p/f331bd5ce8f8 weak由runtime持有的weak_table实现，每个对象有对应的weak_entry_t 获取oldobj(弱引用所指向的之前对象) unregister，替换为newobj的hashtable, register，weak表是hash表，对象的weak指针数组，销毁对象的时候所有weakrefernce置为nil KVO 实现原理参考：https://juejin.cn/post/6844903593925935117 iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类(KVONOtification)，子类拥有自己的set方法实现，set方法实现内部会顺序调用willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。 如何扩大点击区域事件响应链会调用pointInSide，重写pointInSide，edgeInsets扩大范围检测 OC实现链式调用https://juejin.cn/post/7010958824933130253 提供返回block的方法， block内部返回self，返回self是实现链式的核心。 自动释放池内对象释放时机https://juejin.cn/post/7010726670181253127 自动释放池对象AutoreleasePool被销毁时，有可能是当前runloop结束进入休眠，会对池内的所有对象发送release指令。本质是有个双向链表存储所有池内对象，一页放满就新建一页，放入新的页面中。 Struct和Class的区别 Comparision |Class Structure Type Classes are reference types. Structures are value types. Inheritance Classes have an inheritance that allows one class to inherit the characteristics of another. Structures do not support inheritance. Storage Class instances are stored on the heap. Structure properties are stored on the stack. Initializer We have to define the initializer manually. Struct gets a default initializer automatically. Thread−safe Classes are not fully thread−safe. The structure is thread−safe or singleton at all times. Category实现原理https://juejin.cn/post/6844903602524274696 从源码基本可以看出我们平时使用categroy的方式，对象方法，类方法，协议，和属性都可以找到对应的存储方式。并且我们发现分类结构体中是不存在成员变量的，因此分类中是不允许添加成员变量的。分类中添加的属性并不会帮助我们自动生成成员变量，只会生成get set方法的声明，需要我们自己去实现。 category的方法会在运行时加到原来类的方法列表之前，所有category的方法协议会覆盖原来类的方法和协议等。 category中有load方法，先执行原来的load方法，load方法在类加载时候调用,initalize在类第一次使用的时候调用。 关联对象（添加新的成员变量）https://juejin.cn/post/6844903605347057672 AssociationsManager拥有AssociationsHashMap&#x3D;&gt;value为ObjectAssociationMap&#x3D;&gt;valuew为ObjcAssociation（set_assoicated设置的_policy、value）。 通过上图我们可以总结为：一个实例对象就对应一个ObjectAssociationMap，而ObjectAssociationMap中存储着多个此实例对象的关联对象的key以及ObjcAssociation，为ObjcAssociation中存储着关联对象的value和policy策略。 GCDhttps://www.jianshu.com/p/2d57c72016c6 主队列上执行同步任务卡死的原因1234567891011dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; // 异步执行 + 串行队列 NSLog(@&quot;add task&quot;); NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 dispatch_sync(queue, ^&#123; // 同步执行 + 当前串行队列 // 追加任务 1 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;); &#125;); dispatch_sync添加的任务执行完以后才会返回，因为是串行队列，所有只有dispatch_sync任务执行完，才会执行下一个任务【追加任务 1】，所有一直追加任务等待dispatch_sync执行完成主队列是串行队列，跟这个情况一样。 block为什么用copy修饰?默认情况下，block 是存放在栈中即 NSStackBlock ，因此 block 在函数调用结束时，对象会变成 nil，但是对象的指针变成野指针，因此对象继续调用会产生异常。使用 copy 修饰之后，会将 block 对象保存到堆中 NSMallocBlock，它的生命周期会随着对象的销毁而结束的。所以函数调用结束之后指针也会被设置为 nil，再次调用该对象也不会产生异常。 Attention：MRC情况下，ARC无事，自动copy，为了统一可以加copy iOS保证线程安全的几种方式https://juejin.cn/post/6965770220921159694 OSSpinLock os_unfair_lock pthread_mutex dispatch_semaphore dispatch_queue(DISPATCH_QUEUE_SERIAL) NSLock NSRecursiveLock NSCondition NSConditionLock @synchronized CollectionNSSet和NSDictionary都是用hash，查找比较高效。 NSSet对应NSHashTable, NSDictionary对应NSMapTable。 区别都是后者是可变的，且可以对成员进行弱引用，当对象被销毁时，锁存储的实体可以会被移除。 引用计数表保存在哪里参考链接： https://www.jianshu.com/p/43571ab79821 nonpointer:extra_rc +sidetable_rc;非nonpointer: SideTable（静态变量）,散列表，SideTables 如果isa中无法存储指针，那么就存储在SideTable中的RefcountMap中 iOS启动流程参考文档：https://juejin.cn/post/6951591401528229895 12345678910111. 解析Info.plist2. Mach-O（可执行文件）加载 * dylib loading time（动态库加载耗时） * rebase/binding time（偏移修正/符号绑定耗时 * 加载类扩展（Category）中的方法 * C++静态对象加载、调用ObjC的 +load 函数 * 执行声明为__attribute__((constructor))的C函数3. 程序执行 * 调用main() * 调用UIApplicationMain() * 调用applicationWillFinishLaunching @dynamic, @systhesis, @properyhttps://www.jianshu.com/p/c883687c6405 @dynamic 表示用户自己实现get,set方法；（实例变量也需要自己添加）@systheis如果用户没有实现get,set，系统会自己生产get&#x2F;set bounds和frame的关系frame：描述当前视图在其父视图中的位置和大小。 bounds：描述当前视图在其自身坐标系统中的位置和大小。 center：描述当前视图的中心点在其父视图中的位置。所以改变bounds，frame不会动，但相当于自身坐标系往(-bounds.origin.x, -bounds.origin.y）方向移动，影响的是子视图的frame位置（起点变成了(-bounds.origin.x, -bounds.origin.y）） postion、anchorPoint和frame之间的关系首先，view的position等属性就是layer的属性。 12position.x = frame.origin.x + anchorPoint.x * bounds.size.widthposition.y = frame.origin.y + anchorPoint.y * bounds.size.height position和anchorPoint互不影响，都只会影响frame iOS实现动画有几种方式UIView animatiedWith UIView animateKeyframesWithDuration CAbasicAnimation (针对layer的某一属性) CATransition(过渡动画)fade&#x2F;moveIn&#x2F;Push&#x2F;Reval(类似于PPT) KeyAnimation NSTimer问题总结 runloop耗时任务多的时候，会丢失 Timer造成循环引用：NSProxy, 中间件（target为另一个对象） runloop没有释放，一直存在引用 打破的地方就是timer对self的强引用 https://juejin.cn/post/7016633863241728014 runtime的一些应用参考文档： https://juejin.cn/post/7086379028323516452 https://blog.csdn.net/weixin_38735568/article/details/95939608 动态添加属性 方法交换（hook系统方法）Method Swizzling 字典转模型(Model to Dictionay) iOS数据持久化存储方式参考：https://juejin.cn/post/6844903440586375181 plist(属性列表)文件 Preference(偏好设置) NSKeyedArchiver(归档) FMDB(基于SQLite3 封装的一套OC的API库) CoreData NSString property使用strong还是copy，区别和联系是啥？NSMutableString strong修饰时，会修改原来的内容，造成一些不可预期的效果。 It is still recommended to copy because you want to avoid something passing a mutable string and then changing it without you knowing. A copy guarantees that the string you have will not change. 我们知道NSMutableString是NSString的子类，一个NSString指针可以指向NSMutableString对象，strongString指针指向一个可变字符串是正常的。如上例子可以看出: 当原字符串是NSString时，字符串是不可变的，不管是Strong还是Copy属性的对象，都是指向原对象，Copy操作只是做了次浅拷贝。 当原字符串是NSMutableString时，Strong属性只是增加了原字符串的引用计数，而Copy属性则是对原字符串做了次深拷贝，产生一个新的对象，且Copy属性对象指向这个新的对象,且这个Copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。 这里还有一个性能问题，即在原字符串是NSMutableString，Strong是单纯的增加对象的引用计数，而Copy操作是执行了一次深拷贝，所以性能上会有所差异(虽然不大)。如果原字符串是NSString时，则没有这个问题。 苹果登录流程 客户端用appleID&#x2F;邮箱密码请求,返回个人信息和token 将token和userID给后端 后端向苹果后端请求解密token的公钥 后端用公钥,基于JSW算法验证token 返回客户端告知结果 iOS消息转发经典崩溃（启发点）unrecognized selector sent to instance 0x100524a90先来看个很经典的崩溃打印。一般这个日志前部分还会给出所调用的方法，我们可以借此很快找到原因所在，可以说是相当贴心了。然而，苹果在方便我们的同时，你是否想过这个日志具体是在什么时候打印的，系统是靠什么来捕获这类型即将崩溃的信息，开发者是否也可以捕获呢。这些都要从消息转发流程说起，看完分析或许你心里就有答案了。 这段描述很好，为此引为参考，来源https://juejin.cn/post/6857013884298133517 流程速记• 【快速查找流程】首先，在类的缓存cache中查找指定方法的实现• 【慢速查找流程】如果缓存中没有找到，则在类的方法列表中查找，如果还是没找到，则去父类链的缓存和方法列表中查找• 【动态方法决议】如果慢速查找还是没有找到时，第一次补救机会就是尝试一次动态方法决议，即重写resolveInstanceMethod/resolveClassMethod方法,class_addMethod添加方法• 【消息转发】如果动态方法决议还是没有找到，则进行消息转发，消息转发中有两次补救机会：快速转发+慢速转发• 如果转发之后也没有，则程序直接报错崩溃&#96;unrecognized selector sent to instance&#96;&#96; 应用一些容易造成奔溃的方法添加保护，如NSArray访问数组越界的情况，可以用消息转发添加保护。 参考文档 https://juejin.cn/post/6844903600968171533 KeyChain账号密码，token用KeyChain保存，删除App，KeyChain中的数据仍然存在，因为数据是iOS系统保存的 iOS 通知的线程是在哪个线程https://www.jianshu.com/p/e368a18ca7c2 runloop和线程的关系 一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。 我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。 RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。 主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。 如何实现常驻线程参考：iOS 常驻线程 实现思路：给runloop添加port虚拟接口监听 如何让常驻线程退出：添加标识位，使用[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];，这样接收到端口处理信号,标志位结束，退出循环，执行完最后一次后线程结束 线程创建使用block，防止对self出现循环引用。 NSOperation参考： https://juejin.cn/post/6844904053906866189 为什么要使用 NSOperation、NSOperationQueue？ 可以方便的调用cancel方法来取消某个操作，而 GCD 中的任务是无法被取消的。 可以方指定操作间的依赖关系, 方便的控制执行顺序。 可以通过KVO提供对操作对象的精细控制(如监听当前操作是否被取消或是否已经完成等)。 可以方便的指定操作优先级。 可以自定义NSOperation的子类可以实现操作重用. dealloc123- (void)dealloc &#123; _objc_rootDealloc(self);&#125; 直接调用_objc_rootDealloc方法来做处理，我们省略一些细节处理，通常情况下，dealloc方法最终会调用objc_dispose方法，内部又调用objc_destructInstance方法来进行析构操作，析构完成后将内存释放掉。 dealloc的调用是在最后一次release执行后，但此时实例变量(ivars)并未释放。 [super dealloc]会自动调用： 父类的dealloc方法会在子类dealloc方法返回后自动执行。 ARC子类的实例变量在根类[NSObject dealloc]中释放。 load父类load调用在子类之前，分类的load在主类load调用完后执行 iOS websocket使用参考： https://www.jianshu.com/p/80d1440b7012知名库： https://github.com/facebookincubator/SocketRocket 主要api: open close sendData&#x2F;sendString didReceviceMessage didFailWithError didCloseWithCode iOS 沙盒参考：https://www.yuukizoom.top/2021/03/15/iOS%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6/ MyApp.app ： 该目录存放应用本身的数据，包括资源文件和可执行文件。该目录是只读的，如果改变这个目录，将会改变应用程序的签名，应用将会无法启动。不会被iTunes和iCloud同步。 Documents: 该目录主要存放用户产生的文件，该目录会被iTunes和iCloud同步。 Library: 苹果建议用来存放默认设置或其他状态信息，该目录除Caches子目录以外会被iTunes和iCloud同步。 Library&#x2F;Caches: 主要存放缓存文件，比如音乐缓存，图片缓存等，用户使用过程中的缓存都可以保存在这个目录中，可用于保存可再生文件，应用程序也需要负责删除这些文件，该目录不会被iTunes和iCloud同步。 Library&#x2F;Preferences: 存放应用偏好设置文件，该目录会被iTunes和iCloud同步。 tmp: 存放各种临时文件，保存应用再次启动时不需要的文件。当应用不再需要这些文件时应该主动将其删除。该目录的文件会被系统清理，比如系统磁盘空间不足的时候。该目录不会被iTunes和iCloud同步。 使用Runloop进行卡顿检测RunLoop过程 Runloop 状态123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry , // 进入 loop kCFRunLoopBeforeTimers , // 触发 Timer 回调 kCFRunLoopBeforeSources , // 触发 Source0 回调 kCFRunLoopBeforeWaiting , // 等待 mach_port 消息 kCFRunLoopAfterWaiting ), // 接收 mach_port 消息 kCFRunLoopExit , // 退出 loop kCFRunLoopAllActivities // loop 所有状态改变&#125; 所以只要检测进入休眠前，一定时间内(3s)是否一直处于kCFRunLoopBeforeSources或者休眠唤醒以后一直处于kCFRunLoopAfterWaiting状态，就能认为是否卡顿。 卡顿卡顿产生的一些原因 IO 大图加载 高度计算 解决卡顿CPU 使用轻量级的对象：比如不用点击的地方，使用CALayer代替UIView; 不要频繁的修改属性：frame，bounds，transfrom等，这些都需要CPU的计算; 尽量提前计算好布局：计算好frame，bounds等，一次性修改，不要多次修改; 使用AutoLayout比直接设置frame消耗更多的资源; 图片的size最好和UIImageView的size保持一致，这样就不用耗费CPU资源去进行缩放操作; 控制线程的最大并发数量：比如说3，不要无限制的开辟新的线程; 尽量耗时操作放到子线程。 GPU 尽量减少视图的数量和层级：多层次的视图绘制更占用GPU资源; 尽量避免短时间大量图片的显示：可以合成为一张图片展示; GPU能处理的图片的最大尺寸是4096x4096,尽量不要超过这个尺寸; 减少透明视图的使用 alpha &lt; 1,重叠部分：有透明度：需要混合计算;不透明：计算一次(最上层的颜色); 避免离屏渲染。 离屏渲染https://juejin.cn/post/7043676783735996424 FrameBuffer OffScreenBuffer:单独开辟内存，内容切换 触发离屏渲染的几种情况 使用了mask的layer（layer.mask） 需要进行裁剪的layer（layer.masksToBounds &#x2F; view.clipsToBounds） 设置了组透明度YES,并且透明度不为1的layer （layer.allowsGroupOpacity&#x2F;layer.opacity） 添加了投影的layer（layer.shadow） 采用了光栅化的layer（layer.shouldRasterize） 绘制了文字的layer （UILabel，CATextLayer，CoreText等） 离屏渲染优化 大量应用AsyncDisplayKit(Texture)作为主要渲染框架，对于文字和图片的异步渲染操作交由框架来处理。关于这方面可以看之前的一些介绍 对于图片的圆角，统一采用“precomposite”的策略，也就是不经由容器来做剪切，而是预先使用CoreGraphics为图片裁剪圆角 对于视频的圆角，由于实时剪切非常消耗性能，我们会创建四个白色弧形的layer盖住四个角，从视觉上制造圆角的效果 对于view的圆形边框，如果没有backgroundColor，可以放心使用cornerRadius来做 对于所有的阴影，使用shadowPath来规避离屏渲染 对于特殊形状的view，使用layer mask并打开shouldRasterize来对渲染结果进行缓存 对于模糊效果，不采用系统提供的UIVisualEffect，而是另外实现模糊效果（CIGaussianBlur），并手动管理渲染结果 手势冲突如何解决https://www.jianshu.com/p/ce5f54559820 常见的冲突出现的场景： 同一个 UIView 添加了多个相同的手势，却要实现不同的功能； 在UIView和其子UIView上有相同的手势，要实现父子手势的无缝切换等。 常见解决方法 设置手势识别器的delegate，通过代理方法来控制手势的识别； 使用手势识别器的require(toFail:)方法来指定一个手势识别器在另一个手势识别器失效之后才能生qx效； 使用手势识别器的delaysTouchesBegan属性来延迟手势的起始时间； 使用shouldRecognizeSimultaneouslyWith方法来允许多个手势同时识别。 OC为什么是动态语言C++编译期，确定某个对象能调用哪些方法； 动态加载 主要表现在资源的动态加载和代码模块的加载。这些资源在运行时根据需要有选择地加入到程序中。可以降低内存的开销，提高整个程序的性能，也提高了扩展性。 动态绑定 即运行时确定要调用的方法。动态绑定将要调用的方法的确定也推迟到运行时。编译时方法的调用并不和代码绑定一起，只有在消息发送出来之后，才确定被调用的代码。直观点的意思就是在运行时才判断需要调用什么方法。当向一个动态类型确定的对象发送消息时，运行时环境系统会通过接收者的isa指针定对象的类，并以此为起点确定被调用的方法，方法和消息时动态绑定的。 动态类型 指对象指针类型的动态性，具体是指使用id类型将对象的类型推迟到运行时才确定，由赋值给它的对象类型决定对象指针的类型。 通知实现原理通知中心维护了一个 table，table 里面包含了 named表、nameless表、wildcard链表这三个数据结构；当我们调用 addObserver:selector:name:object:方法时，其内部大概是这样实现的： 构造一个 Observation对象，该对象里面保存着 object 和 selector，可以看做是一个链表的节点。 判断传入的 name 是否为空。如果 name 不为空，以 name为 key 从 named 的字典中取出一个 n 字典，然后从 n 字典里面以 object 为 key 取出 observation，再然后把 observation 对象存入链表。 判断传入的 object 是否为空。如果 object 不为空，以 object 为 key 从 namedless 字典中取出 observation 链表，将 observation 对象存入； 如果name 和 object 都为空，则将Observertion 对象存入 wildcard 链表中。发送通知的过程是先判断object，再判断 name。name 的优先级高于 object。 通知的发送是同步的还是异步的？同步的，会调用performSelector:withObject。但是有种情况可以不实时发送通知，而是在合适的时机发送，并没有开启线程，这种说法是指使用 NSOperationQueue，指定发送时机，可以依赖 Runloop 等到下一次循环开始时发送。 NSNotificationCenter 接收消息和发送消息是在同一个线程吗，如何异步发送通知？是的，发送消息在哪个线程，接收消息就在哪个线程。 NSNotificaionQueue 是异步还是同步？在哪个线程响应？没有异步发送一说，只是利用了 Runloop 可以选择触发时机。 NSNotificationQueue 和 Runloop 的关系？前者依赖后者。比如指定 postStyle 的时候 NSPostWhenIdle 表示在 Runloop 空闲的时候发送。此外还有 NSPostASAP，尽可能快 发送，NSPostNow多个相同的通知合并后马上发送。 如何保证通知接收的线程在主线程？使用 block 方式注册通知，在主队列响应。或者是在主线程注册 machPort，这是负责线程通信的，当异步线程收到通知后，给 machport 发送消息。还可以在通知的回调方法里面，使用 GCD 主队列调度方法。 页面销毁时，不移除通知会崩溃吗？iOS9 之后不会了，通知中心对 Observer是弱引用的。 多次添加同一个通知和多次移除同一个通知会是什么结果？多次添加会多次响应。移除没事儿 如何检测在非主线程进行UI操作？参考：通过Runtime机制检测子线程操作UI 简要概述，就是用runtime将UIView的所有方法和属性进行Method Swizzling，进行消息转发，然后在自定义的消息中进行判断是否是主线程。isMainThread。 导致iOS程序崩溃的原因有哪些？ 数组越界 unrecognized selector sent to instance 野指针 解决奔溃问题 Method Swizzling 加防护，返回nil 使用前加判断 OOM监控"},{"title":"algorithms","date":"2023-07-12","path":"2023/07/12/algorithms/","text":"算法和数据结构动态规划 寻找最优子结构 递归定义最优解的值 计算最优解的值，通常使用自底向上的方法 利用计算出的信息构造一个最优解 回溯 DFS+遍历探索每一层的每一种可能 画出所有树状链路就能写出代码 效率比较低 字符串匹配目标字符串T，和匹配模式P（子字符串） 有限自动机 Pattern内部自己构建有限自动机，目标是加上的新的字符以后，最长前缀字符串和目前扫描到的后缀字符串一样 基于构建好的自动机，O(n)扫描字符串，如果中间达到终态，匹配成功；否则，匹配失败 构建有限自动机：对于模式P，和字符集，扫描模式，当前字符a,对于Pi，找寻Pi a的最长前缀Pk，则加字符a，转移到k的状态 算法的复杂度为扫描O(n) + 构建有限自动机的复杂度 &#x3D;&gt; KMP是有限自动机的一种有效实现： 用\\pi添加额外的存储空间，表示P[q]的后缀中最长真前缀，也就是用模式内部的匹配形式，来表达有限自动机。算法执行流程，就是当前字符不匹配的时候，逐步回退到\\pi的地方，再去判断，如何符合就继续，直到回退到开头的形式，这样就利用了模式字符串之前就有的模式子串。 12345678910111213141516171819202122232425KMP-Matcher(T, P) n = T.length m = P.length \\pi = Compute_Prefix_Function(P) for i from 1 to n while q &gt; 0 and P[q+1] != T[i] q = \\pi[q] if P[q+1] == T[i] q == q + 1 if q == m Print &quot;Positon at &quot; m - i q = \\pi[q] // Find next MathcherCompute_Prefix_Function(P) n = P.length k = 0 let \\pi be an new array from 1 to n \\pi[1] = 0 for q from 2 to n while k &gt; 0 and P[k+1] != P[q] k = \\pi[k] if P[k+1] == P[q] k = k + 1 \\pi[q] = k"},{"title":"Hello World","date":"2022-12-31","path":"2022/12/31/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]